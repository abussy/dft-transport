diff --git a/src/InjectionBeyn.H b/src/InjectionBeyn.H
index fa2dae8..881e099 100644
--- a/src/InjectionBeyn.H
+++ b/src/InjectionBeyn.H
@@ -12,6 +12,7 @@ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLI
 #ifndef __INJECTIONBEYN
 #define __INJECTIONBEYN
 
+
 #include <omp.h>
 #include <mpi.h>
 #include <iostream>
@@ -22,6 +23,7 @@ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLI
 #include <math.h>
 #include <time.h>
 #include <vector>
+#include <limits>
 
 #include "Types.H"
 #include "Utilities.H"
@@ -1071,7 +1073,7 @@ int InjectionBeyn<T>::parallel_decompose(CPX *Q1,CPX *Q2,int ND,int NM, MPI_Comm
     c_pzgeadd('N',ND,NM,1.0,Q2,1,1,descQ,0.0,q_dist,1,1,descq);
 
     int NM_new = 0;
-    while(NM_new<ND && Sval[NM_new]>svd_fac*Sval[0]*ND*(numeric_limits<double>::epsilon)()) NM_new++;
+    while(NM_new<ND && Sval[NM_new]>svd_fac*Sval[0]*ND*(std::numeric_limits<double>::epsilon)()) NM_new++;
 
     CPX *UtxQ2_dist = new CPX[rloc*cloc];
     c_pzgemm('C','N',NM_new,NM,ND,CPX(1.0,0.0),u_dist,1,1,descq,q_dist,1,1,descq,CPX(0.0,0.0),UtxQ2_dist,1,1,descq);
@@ -1102,7 +1104,7 @@ int InjectionBeyn<T>::decompose(CPX *Q1,CPX *Q2,int ND,int NM)
     CPX *vtrans = new CPX[NM*NM];
     if (svd(Q1,vtrans,Sval,ND,NM)) return 0;
     int NM_new = 0;
-    while(NM_new<ND && Sval[NM_new]>svd_fac*Sval[0]*ND*(numeric_limits<double>::epsilon)()) NM_new++;
+    while(NM_new<ND && Sval[NM_new]>svd_fac*Sval[0]*ND*(std::numeric_limits<double>::epsilon)()) NM_new++;
     CPX *UtxQ2 = new CPX[NM_new*NM];
     c_zgemm('C','N',NM_new,NM,ND,CPX(1.0,0.0),Q1,ND,Q2,ND,CPX(0.0,0.0),UtxQ2,NM_new);
     c_zgemm('N','C',NM_new,NM_new,NM,CPX(1.0,0.0),UtxQ2,NM_new,vtrans,NM,CPX(0.0,0.0),Q2,NM_new);
diff --git a/src/SuperLU.H b/src/SuperLU.H
index 41047f8..32d2024 100644
--- a/src/SuperLU.H
+++ b/src/SuperLU.H
@@ -39,9 +39,9 @@ private:
     superlu_dist_options_t options;
     gridinfo_t grid;
     SuperLUStat_t stat;
-    ScalePermstruct_t ScalePermstruct;
-    LUstruct_t LUstruct;
-    SOLVEstruct_t SOLVEstruct;
+    zScalePermstruct_t ScalePermstruct;
+    zLUstruct_t LUstruct;
+    zSOLVEstruct_t SOLVEstruct;
 
     void create_local_matrix(TCSR<T>*,SuperMatrix*);
 };
@@ -75,9 +75,9 @@ SuperLU<CPX>::~SuperLU()
     
     PStatFree(&stat);
     Destroy_CompRowLoc_Matrix_dist(&A);
-    ScalePermstructFree(&ScalePermstruct);
-    Destroy_LU(n,&grid, &LUstruct);
-    LUstructFree(&LUstruct);
+    zScalePermstructFree(&ScalePermstruct);
+    zDestroy_LU(n,&grid, &LUstruct);
+    zLUstructFree(&LUstruct);
     zSolveFinalize(&options, &SOLVEstruct);
 
     //superlu_gridexit(&grid);
@@ -106,9 +106,9 @@ void SuperLU<CPX>::prepare()
 {
     int info;
 
-    ScalePermstructInit(A.nrow,A.ncol,&ScalePermstruct);
+    zScalePermstructInit(A.nrow,A.ncol,&ScalePermstruct);
 //    LUstructInit(A.nrow,A.ncol,&LUstruct);
-    LUstructInit(A.ncol,&LUstruct);
+    zLUstructInit(A.ncol,&LUstruct);
 
     PStatInit(&stat);
     
diff --git a/src/c_scf.C b/src/c_scf.C
index e77d9bf..75bd7c3 100644
--- a/src/c_scf.C
+++ b/src/c_scf.C
@@ -15,6 +15,7 @@ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLI
 #endif
 #include "EnergyVector.H"
 #include <numeric>
+#include <limits>
 
 void write_cp2k_csr(cp2k_csr_interop_type& cp2kCSRmat,const char* filename)
 {
@@ -284,8 +285,8 @@ void c_scf_method(cp2k_transport_parameters cp2k_transport_params, cp2k_csr_inte
         transport_params.inv_solver_method           = static_cast<inv_solver_methods::inv_solver_method_type>(cp2k_transport_params.matrixinv_method);
         transport_params.real_int_method             = static_cast<real_int_methods::real_int_method_type>(cp2k_transport_params.rlaxis_integration_method);
         transport_params.cp2k_method                 = static_cast<cp2k_methods::cp2k_method_type>(cp2k_transport_params.method);
-        if (cp2k_transport_params.eps_fermi<=(numeric_limits<double>::epsilon)()) {
-            transport_params.eps_fermi               = (numeric_limits<double>::epsilon)();
+        if (cp2k_transport_params.eps_fermi<=(std::numeric_limits<double>::epsilon)()) {
+            transport_params.eps_fermi               = (std::numeric_limits<double>::epsilon)();
         } else {
             transport_params.eps_fermi               = cp2k_transport_params.eps_fermi;
         }
